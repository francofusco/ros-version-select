#!/bin/bash

# If the environment variable ROS_VERSION_SELECT_DIR has not been defined, just exit.
if [[ -z "$ROS_VERSION_SELECT_DIR" ]]; then
  echo "Sorry, the environment variable 'ROS_VERSION_SELECT_DIR' has not been defined. Please, set it in order to use ros-version-select utilities."
  return
fi


# Function to be called after completing a "setup command".
cleanup_command() {
  # TODO: I would love to execute something like this:
  #   gnome-terminal && exit
  # however, it does not start a "fresh terminal"...
  echo "Switch completed! Please close this terminal and open a new one :)"
}


# Function that can be used to source a specific ROS version.
# It accepts one parameter, consisting in the ROS version to be sourced. It can
# be anything, but any value different from 1 or 2 will "deactivate" ROS.
source_rosX() {
  if [[ $1 != 1 && $1 != 2 ]]; then
    echo "All ROS versions have been deactivated"
  else
    source "$ROS_VERSION_SELECT_DIR/config-ros$ROS_VERSION_SELECT_USE_VERSION.bash"
  fi
}


# Function that annotates the ROS version to be used when opening a new console.
activate_rosX() {
  version_file="$ROS_VERSION_SELECT_DIR/ros-version.bash"
  touch "$version_file"
  echo "# THIS FILE WAS AUTOGENERATED. PLEASE DO NOT MODIFY ITS CONTENT DIRECTLY." > "$version_file"
  if [[ $1 != 1 && $1 != 2 ]]; then
    echo "export ROS_VERSION_SELECT_USE_VERSION=0" >> "$version_file"
  else
    echo "export ROS_VERSION_SELECT_USE_VERSION=$1" >> "$version_file"
  fi
  cleanup_command $1
}


# These are basically aliases to (de)activate ROS.
deactivate_ros() { activate_rosX 0; }
activate_ros1() { activate_rosX 1; }
activate_ros2() { activate_rosX 2; }


# If the version file 'ros-version.bash' does not exist, generate an empty one.
if [ ! -f "$ROS_VERSION_SELECT_DIR/ros-version.bash" ]; then deactivate_ros; fi
# Finally, source the proper ros version
source "$ROS_VERSION_SELECT_DIR/ros-version.bash"
source_rosX "$ROS_VERSION_SELECT_USE_VERSION"
